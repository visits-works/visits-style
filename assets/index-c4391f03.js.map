{"version":3,"file":"index-c4391f03.js","sources":["../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs","../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs","../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js","../../node_modules/aria-hidden/dist/es2015/index.js","../../node_modules/tabbable/dist/index.esm.js","../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js","../../src/components/Portal/index.tsx"],"sourcesContent":["function t(t){return t.split(\"-\")[1]}function e(t){return\"y\"===t?\"height\":\"width\"}function n(t){return t.split(\"-\")[0]}function o(t){return[\"top\",\"bottom\"].includes(n(t))?\"x\":\"y\"}function i(i,r,a){let{reference:l,floating:s}=i;const c=l.x+l.width/2-s.width/2,f=l.y+l.height/2-s.height/2,m=o(r),u=e(m),g=l[u]/2-s[u]/2,d=\"x\"===m;let p;switch(n(r)){case\"top\":p={x:c,y:l.y-s.height};break;case\"bottom\":p={x:c,y:l.y+l.height};break;case\"right\":p={x:l.x+l.width,y:f};break;case\"left\":p={x:l.x-s.width,y:f};break;default:p={x:l.x,y:l.y}}switch(t(r)){case\"start\":p[m]-=g*(a&&d?-1:1);break;case\"end\":p[m]+=g*(a&&d?-1:1)}return p}const r=async(t,e,n)=>{const{placement:o=\"bottom\",strategy:r=\"absolute\",middleware:a=[],platform:l}=n,s=a.filter(Boolean),c=await(null==l.isRTL?void 0:l.isRTL(e));let f=await l.getElementRects({reference:t,floating:e,strategy:r}),{x:m,y:u}=i(f,o,c),g=o,d={},p=0;for(let n=0;n<s.length;n++){const{name:a,fn:h}=s[n],{x:y,y:x,data:w,reset:v}=await h({x:m,y:u,initialPlacement:o,placement:g,strategy:r,middlewareData:d,rects:f,platform:l,elements:{reference:t,floating:e}});m=null!=y?y:m,u=null!=x?x:u,d={...d,[a]:{...d[a],...w}},v&&p<=50&&(p++,\"object\"==typeof v&&(v.placement&&(g=v.placement),v.rects&&(f=!0===v.rects?await l.getElementRects({reference:t,floating:e,strategy:r}):v.rects),({x:m,y:u}=i(f,g,c))),n=-1)}return{x:m,y:u,placement:g,strategy:r,middlewareData:d}};function a(t,e){return\"function\"==typeof t?t(e):t}function l(t){return\"number\"!=typeof t?function(t){return{top:0,right:0,bottom:0,left:0,...t}}(t):{top:t,right:t,bottom:t,left:t}}function s(t){return{...t,top:t.y,left:t.x,right:t.x+t.width,bottom:t.y+t.height}}async function c(t,e){var n;void 0===e&&(e={});const{x:o,y:i,platform:r,rects:c,elements:f,strategy:m}=t,{boundary:u=\"clippingAncestors\",rootBoundary:g=\"viewport\",elementContext:d=\"floating\",altBoundary:p=!1,padding:h=0}=a(e,t),y=l(h),x=f[p?\"floating\"===d?\"reference\":\"floating\":d],w=s(await r.getClippingRect({element:null==(n=await(null==r.isElement?void 0:r.isElement(x)))||n?x:x.contextElement||await(null==r.getDocumentElement?void 0:r.getDocumentElement(f.floating)),boundary:u,rootBoundary:g,strategy:m})),v=\"floating\"===d?{...c.floating,x:o,y:i}:c.reference,b=await(null==r.getOffsetParent?void 0:r.getOffsetParent(f.floating)),A=await(null==r.isElement?void 0:r.isElement(b))&&await(null==r.getScale?void 0:r.getScale(b))||{x:1,y:1},R=s(r.convertOffsetParentRelativeRectToViewportRelativeRect?await r.convertOffsetParentRelativeRectToViewportRelativeRect({rect:v,offsetParent:b,strategy:m}):v);return{top:(w.top-R.top+y.top)/A.y,bottom:(R.bottom-w.bottom+y.bottom)/A.y,left:(w.left-R.left+y.left)/A.x,right:(R.right-w.right+y.right)/A.x}}const f=Math.min,m=Math.max;function u(t,e,n){return m(t,f(e,n))}const g=n=>({name:\"arrow\",options:n,async fn(i){const{x:r,y:s,placement:c,rects:m,platform:g,elements:d}=i,{element:p,padding:h=0}=a(n,i)||{};if(null==p)return{};const y=l(h),x={x:r,y:s},w=o(c),v=e(w),b=await g.getDimensions(p),A=\"y\"===w,R=A?\"top\":\"left\",P=A?\"bottom\":\"right\",E=A?\"clientHeight\":\"clientWidth\",T=m.reference[v]+m.reference[w]-x[w]-m.floating[v],D=x[w]-m.reference[w],L=await(null==g.getOffsetParent?void 0:g.getOffsetParent(p));let k=L?L[E]:0;k&&await(null==g.isElement?void 0:g.isElement(L))||(k=d.floating[E]||m.floating[v]);const O=T/2-D/2,B=k/2-b[v]/2-1,C=f(y[R],B),H=f(y[P],B),S=C,F=k-b[v]-H,M=k/2-b[v]/2+O,V=u(S,M,F),W=null!=t(c)&&M!=V&&m.reference[v]/2-(M<S?C:H)-b[v]/2<0?M<S?S-M:F-M:0;return{[w]:x[w]-W,data:{[w]:V,centerOffset:M-V+W}}}}),d=[\"top\",\"right\",\"bottom\",\"left\"],p=d.reduce(((t,e)=>t.concat(e,e+\"-start\",e+\"-end\")),[]),h={left:\"right\",right:\"left\",bottom:\"top\",top:\"bottom\"};function y(t){return t.replace(/left|right|bottom|top/g,(t=>h[t]))}function x(n,i,r){void 0===r&&(r=!1);const a=t(n),l=o(n),s=e(l);let c=\"x\"===l?a===(r?\"end\":\"start\")?\"right\":\"left\":\"start\"===a?\"bottom\":\"top\";return i.reference[s]>i.floating[s]&&(c=y(c)),{main:c,cross:y(c)}}const w={start:\"end\",end:\"start\"};function v(t){return t.replace(/start|end/g,(t=>w[t]))}const b=function(e){return void 0===e&&(e={}),{name:\"autoPlacement\",options:e,async fn(o){var i,r,l;const{rects:s,middlewareData:f,placement:m,platform:u,elements:g}=o,{crossAxis:d=!1,alignment:h,allowedPlacements:y=p,autoAlignment:w=!0,...b}=a(e,o),A=void 0!==h||y===p?function(e,o,i){return(e?[...i.filter((n=>t(n)===e)),...i.filter((n=>t(n)!==e))]:i.filter((t=>n(t)===t))).filter((n=>!e||t(n)===e||!!o&&v(n)!==n))}(h||null,w,y):y,R=await c(o,b),P=(null==(i=f.autoPlacement)?void 0:i.index)||0,E=A[P];if(null==E)return{};const{main:T,cross:D}=x(E,s,await(null==u.isRTL?void 0:u.isRTL(g.floating)));if(m!==E)return{reset:{placement:A[0]}};const L=[R[n(E)],R[T],R[D]],k=[...(null==(r=f.autoPlacement)?void 0:r.overflows)||[],{placement:E,overflows:L}],O=A[P+1];if(O)return{data:{index:P+1,overflows:k},reset:{placement:O}};const B=k.map((e=>{const n=t(e.placement);return[e.placement,n&&d?e.overflows.slice(0,2).reduce(((t,e)=>t+e),0):e.overflows[0],e.overflows]})).sort(((t,e)=>t[1]-e[1])),C=(null==(l=B.filter((e=>e[2].slice(0,t(e[0])?2:3).every((t=>t<=0))))[0])?void 0:l[0])||B[0][0];return C!==m?{data:{index:P+1,overflows:k},reset:{placement:C}}:{}}}};const A=function(e){return void 0===e&&(e={}),{name:\"flip\",options:e,async fn(o){var i;const{placement:r,middlewareData:l,rects:s,initialPlacement:f,platform:m,elements:u}=o,{mainAxis:g=!0,crossAxis:d=!0,fallbackPlacements:p,fallbackStrategy:h=\"bestFit\",fallbackAxisSideDirection:w=\"none\",flipAlignment:b=!0,...A}=a(e,o),R=n(r),P=n(f)===f,E=await(null==m.isRTL?void 0:m.isRTL(u.floating)),T=p||(P||!b?[y(f)]:function(t){const e=y(t);return[v(t),e,v(e)]}(f));p||\"none\"===w||T.push(...function(e,o,i,r){const a=t(e);let l=function(t,e,n){const o=[\"left\",\"right\"],i=[\"right\",\"left\"],r=[\"top\",\"bottom\"],a=[\"bottom\",\"top\"];switch(t){case\"top\":case\"bottom\":return n?e?i:o:e?o:i;case\"left\":case\"right\":return e?r:a;default:return[]}}(n(e),\"start\"===i,r);return a&&(l=l.map((t=>t+\"-\"+a)),o&&(l=l.concat(l.map(v)))),l}(f,b,w,E));const D=[f,...T],L=await c(o,A),k=[];let O=(null==(i=l.flip)?void 0:i.overflows)||[];if(g&&k.push(L[R]),d){const{main:t,cross:e}=x(r,s,E);k.push(L[t],L[e])}if(O=[...O,{placement:r,overflows:k}],!k.every((t=>t<=0))){var B,C;const t=((null==(B=l.flip)?void 0:B.index)||0)+1,e=D[t];if(e)return{data:{index:t,overflows:O},reset:{placement:e}};let n=null==(C=O.filter((t=>t.overflows[0]<=0)).sort(((t,e)=>t.overflows[1]-e.overflows[1]))[0])?void 0:C.placement;if(!n)switch(h){case\"bestFit\":{var H;const t=null==(H=O.map((t=>[t.placement,t.overflows.filter((t=>t>0)).reduce(((t,e)=>t+e),0)])).sort(((t,e)=>t[1]-e[1]))[0])?void 0:H[0];t&&(n=t);break}case\"initialPlacement\":n=f}if(r!==n)return{reset:{placement:n}}}return{}}}};function R(t,e){return{top:t.top-e.height,right:t.right-e.width,bottom:t.bottom-e.height,left:t.left-e.width}}function P(t){return d.some((e=>t[e]>=0))}const E=function(t){return void 0===t&&(t={}),{name:\"hide\",options:t,async fn(e){const{rects:n}=e,{strategy:o=\"referenceHidden\",...i}=a(t,e);switch(o){case\"referenceHidden\":{const t=R(await c(e,{...i,elementContext:\"reference\"}),n.reference);return{data:{referenceHiddenOffsets:t,referenceHidden:P(t)}}}case\"escaped\":{const t=R(await c(e,{...i,altBoundary:!0}),n.floating);return{data:{escapedOffsets:t,escaped:P(t)}}}default:return{}}}}};function T(t){const e=f(...t.map((t=>t.left))),n=f(...t.map((t=>t.top)));return{x:e,y:n,width:m(...t.map((t=>t.right)))-e,height:m(...t.map((t=>t.bottom)))-n}}const D=function(t){return void 0===t&&(t={}),{name:\"inline\",options:t,async fn(e){const{placement:i,elements:r,rects:c,platform:u,strategy:g}=e,{padding:d=2,x:p,y:h}=a(t,e),y=Array.from(await(null==u.getClientRects?void 0:u.getClientRects(r.reference))||[]),x=function(t){const e=t.slice().sort(((t,e)=>t.y-e.y)),n=[];let o=null;for(let t=0;t<e.length;t++){const i=e[t];!o||i.y-o.y>o.height/2?n.push([i]):n[n.length-1].push(i),o=i}return n.map((t=>s(T(t))))}(y),w=s(T(y)),v=l(d);const b=await u.getElementRects({reference:{getBoundingClientRect:function(){if(2===x.length&&x[0].left>x[1].right&&null!=p&&null!=h)return x.find((t=>p>t.left-v.left&&p<t.right+v.right&&h>t.top-v.top&&h<t.bottom+v.bottom))||w;if(x.length>=2){if(\"x\"===o(i)){const t=x[0],e=x[x.length-1],o=\"top\"===n(i),r=t.top,a=e.bottom,l=o?t.left:e.left,s=o?t.right:e.right;return{top:r,bottom:a,left:l,right:s,width:s-l,height:a-r,x:l,y:r}}const t=\"left\"===n(i),e=m(...x.map((t=>t.right))),r=f(...x.map((t=>t.left))),a=x.filter((n=>t?n.left===r:n.right===e)),l=a[0].top,s=a[a.length-1].bottom;return{top:l,bottom:s,left:r,right:e,width:e-r,height:s-l,x:r,y:l}}return w}},floating:r.floating,strategy:g});return c.reference.x!==b.reference.x||c.reference.y!==b.reference.y||c.reference.width!==b.reference.width||c.reference.height!==b.reference.height?{reset:{rects:b}}:{}}}};const L=function(e){return void 0===e&&(e=0),{name:\"offset\",options:e,async fn(i){const{x:r,y:l}=i,s=await async function(e,i){const{placement:r,platform:l,elements:s}=e,c=await(null==l.isRTL?void 0:l.isRTL(s.floating)),f=n(r),m=t(r),u=\"x\"===o(r),g=[\"left\",\"top\"].includes(f)?-1:1,d=c&&u?-1:1,p=a(i,e);let{mainAxis:h,crossAxis:y,alignmentAxis:x}=\"number\"==typeof p?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...p};return m&&\"number\"==typeof x&&(y=\"end\"===m?-1*x:x),u?{x:y*d,y:h*g}:{x:h*g,y:y*d}}(i,e);return{x:r+s.x,y:l+s.y,data:s}}}};function k(t){return\"x\"===t?\"y\":\"x\"}const O=function(t){return void 0===t&&(t={}),{name:\"shift\",options:t,async fn(e){const{x:i,y:r,placement:l}=e,{mainAxis:s=!0,crossAxis:f=!1,limiter:m={fn:t=>{let{x:e,y:n}=t;return{x:e,y:n}}},...g}=a(t,e),d={x:i,y:r},p=await c(e,g),h=o(n(l)),y=k(h);let x=d[h],w=d[y];if(s){const t=\"y\"===h?\"bottom\":\"right\";x=u(x+p[\"y\"===h?\"top\":\"left\"],x,x-p[t])}if(f){const t=\"y\"===y?\"bottom\":\"right\";w=u(w+p[\"y\"===y?\"top\":\"left\"],w,w-p[t])}const v=m.fn({...e,[h]:x,[y]:w});return{...v,data:{x:v.x-i,y:v.y-r}}}}},B=function(t){return void 0===t&&(t={}),{options:t,fn(e){const{x:i,y:r,placement:l,rects:s,middlewareData:c}=e,{offset:f=0,mainAxis:m=!0,crossAxis:u=!0}=a(t,e),g={x:i,y:r},d=o(l),p=k(d);let h=g[d],y=g[p];const x=a(f,e),w=\"number\"==typeof x?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(m){const t=\"y\"===d?\"height\":\"width\",e=s.reference[d]-s.floating[t]+w.mainAxis,n=s.reference[d]+s.reference[t]-w.mainAxis;h<e?h=e:h>n&&(h=n)}if(u){var v,b;const t=\"y\"===d?\"width\":\"height\",e=[\"top\",\"left\"].includes(n(l)),o=s.reference[p]-s.floating[t]+(e&&(null==(v=c.offset)?void 0:v[p])||0)+(e?0:w.crossAxis),i=s.reference[p]+s.reference[t]+(e?0:(null==(b=c.offset)?void 0:b[p])||0)-(e?w.crossAxis:0);y<o?y=o:y>i&&(y=i)}return{[d]:h,[p]:y}}}},C=function(e){return void 0===e&&(e={}),{name:\"size\",options:e,async fn(i){const{placement:r,rects:l,platform:s,elements:u}=i,{apply:g=(()=>{}),...d}=a(e,i),p=await c(i,d),h=n(r),y=t(r),x=\"x\"===o(r),{width:w,height:v}=l.floating;let b,A;\"top\"===h||\"bottom\"===h?(b=h,A=y===(await(null==s.isRTL?void 0:s.isRTL(u.floating))?\"start\":\"end\")?\"left\":\"right\"):(A=h,b=\"end\"===y?\"top\":\"bottom\");const R=v-p[b],P=w-p[A],E=!i.middlewareData.shift;let T=R,D=P;if(x){const t=w-p.left-p.right;D=y||E?f(P,t):t}else{const t=v-p.top-p.bottom;T=y||E?f(R,t):t}if(E&&!y){const t=m(p.left,0),e=m(p.right,0),n=m(p.top,0),o=m(p.bottom,0);x?D=w-2*(0!==t||0!==e?t+e:m(p.left,p.right)):T=v-2*(0!==n||0!==o?n+o:m(p.top,p.bottom))}await g({...i,availableWidth:D,availableHeight:T});const L=await s.getDimensions(u.floating);return w!==L.width||v!==L.height?{reset:{rects:!0}}:{}}}};export{g as arrow,b as autoPlacement,r as computePosition,c as detectOverflow,A as flip,E as hide,D as inline,B as limitShift,L as offset,s as rectToClientRect,O as shift,C as size};\n","import{rectToClientRect as t,computePosition as e}from\"@floating-ui/core\";export{arrow,autoPlacement,detectOverflow,flip,hide,inline,limitShift,offset,shift,size}from\"@floating-ui/core\";function n(t){var e;return(null==(e=t.ownerDocument)?void 0:e.defaultView)||window}function o(t){return n(t).getComputedStyle(t)}function i(t){return t instanceof n(t).Node}function r(t){return i(t)?(t.nodeName||\"\").toLowerCase():\"#document\"}function c(t){return t instanceof n(t).HTMLElement}function l(t){return t instanceof n(t).Element}function s(t){return\"undefined\"!=typeof ShadowRoot&&(t instanceof n(t).ShadowRoot||t instanceof ShadowRoot)}function f(t){const{overflow:e,overflowX:n,overflowY:i,display:r}=o(t);return/auto|scroll|overlay|hidden|clip/.test(e+i+n)&&![\"inline\",\"contents\"].includes(r)}function u(t){return[\"table\",\"td\",\"th\"].includes(r(t))}function a(t){const e=d(),n=o(t);return\"none\"!==n.transform||\"none\"!==n.perspective||!!n.containerType&&\"normal\"!==n.containerType||!e&&!!n.backdropFilter&&\"none\"!==n.backdropFilter||!e&&!!n.filter&&\"none\"!==n.filter||[\"transform\",\"perspective\",\"filter\"].some((t=>(n.willChange||\"\").includes(t)))||[\"paint\",\"layout\",\"strict\",\"content\"].some((t=>(n.contain||\"\").includes(t)))}function d(){return!(\"undefined\"==typeof CSS||!CSS.supports)&&CSS.supports(\"-webkit-backdrop-filter\",\"none\")}function h(t){return[\"html\",\"body\",\"#document\"].includes(r(t))}const p=Math.min,m=Math.max,g=Math.round,y=Math.floor,w=t=>({x:t,y:t});function x(t){const e=o(t);let n=parseFloat(e.width)||0,i=parseFloat(e.height)||0;const r=c(t),l=r?t.offsetWidth:n,s=r?t.offsetHeight:i,f=g(n)!==l||g(i)!==s;return f&&(n=l,i=s),{width:n,height:i,$:f}}function v(t){return l(t)?t:t.contextElement}function b(t){const e=v(t);if(!c(e))return w(1);const n=e.getBoundingClientRect(),{width:o,height:i,$:r}=x(e);let l=(r?g(n.width):n.width)/o,s=(r?g(n.height):n.height)/i;return l&&Number.isFinite(l)||(l=1),s&&Number.isFinite(s)||(s=1),{x:l,y:s}}const L=w(0);function T(t,e,o){var i,r;if(void 0===e&&(e=!0),!d())return L;const c=t?n(t):window;return!o||e&&o!==c?L:{x:(null==(i=c.visualViewport)?void 0:i.offsetLeft)||0,y:(null==(r=c.visualViewport)?void 0:r.offsetTop)||0}}function R(e,o,i,r){void 0===o&&(o=!1),void 0===i&&(i=!1);const c=e.getBoundingClientRect(),s=v(e);let f=w(1);o&&(r?l(r)&&(f=b(r)):f=b(e));const u=T(s,i,r);let a=(c.left+u.x)/f.x,d=(c.top+u.y)/f.y,h=c.width/f.x,p=c.height/f.y;if(s){const t=n(s),e=r&&l(r)?n(r):r;let o=t.frameElement;for(;o&&r&&e!==t;){const t=b(o),e=o.getBoundingClientRect(),i=getComputedStyle(o),r=e.left+(o.clientLeft+parseFloat(i.paddingLeft))*t.x,c=e.top+(o.clientTop+parseFloat(i.paddingTop))*t.y;a*=t.x,d*=t.y,h*=t.x,p*=t.y,a+=r,d+=c,o=n(o).frameElement}}return t({width:h,height:p,x:a,y:d})}function S(t){return((i(t)?t.ownerDocument:t.document)||window.document).documentElement}function E(t){return l(t)?{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}:{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function C(t){return R(S(t)).left+E(t).scrollLeft}function F(t){if(\"html\"===r(t))return t;const e=t.assignedSlot||t.parentNode||s(t)&&t.host||S(t);return s(e)?e.host:e}function O(t){const e=F(t);return h(e)?t.ownerDocument?t.ownerDocument.body:t.body:c(e)&&f(e)?e:O(e)}function D(t,e){var o;void 0===e&&(e=[]);const i=O(t),r=i===(null==(o=t.ownerDocument)?void 0:o.body),c=n(i);return r?e.concat(c,c.visualViewport||[],f(i)?i:[]):e.concat(i,D(i))}function W(e,i,r){let s;if(\"viewport\"===i)s=function(t,e){const o=n(t),i=S(t),r=o.visualViewport;let c=i.clientWidth,l=i.clientHeight,s=0,f=0;if(r){c=r.width,l=r.height;const t=d();(!t||t&&\"fixed\"===e)&&(s=r.offsetLeft,f=r.offsetTop)}return{width:c,height:l,x:s,y:f}}(e,r);else if(\"document\"===i)s=function(t){const e=S(t),n=E(t),i=t.ownerDocument.body,r=m(e.scrollWidth,e.clientWidth,i.scrollWidth,i.clientWidth),c=m(e.scrollHeight,e.clientHeight,i.scrollHeight,i.clientHeight);let l=-n.scrollLeft+C(t);const s=-n.scrollTop;return\"rtl\"===o(i).direction&&(l+=m(e.clientWidth,i.clientWidth)-r),{width:r,height:c,x:l,y:s}}(S(e));else if(l(i))s=function(t,e){const n=R(t,!0,\"fixed\"===e),o=n.top+t.clientTop,i=n.left+t.clientLeft,r=c(t)?b(t):w(1);return{width:t.clientWidth*r.x,height:t.clientHeight*r.y,x:i*r.x,y:o*r.y}}(i,r);else{const t=T(e);s={...i,x:i.x-t.x,y:i.y-t.y}}return t(s)}function H(t,e){const n=F(t);return!(n===e||!l(n)||h(n))&&(\"fixed\"===o(n).position||H(n,e))}function z(t,e){return c(t)&&\"fixed\"!==o(t).position?e?e(t):t.offsetParent:null}function M(t,e){const i=n(t);if(!c(t))return i;let l=z(t,e);for(;l&&u(l)&&\"static\"===o(l).position;)l=z(l,e);return l&&(\"html\"===r(l)||\"body\"===r(l)&&\"static\"===o(l).position&&!a(l))?i:l||function(t){let e=F(t);for(;c(e)&&!h(e);){if(a(e))return e;e=F(e)}return null}(t)||i}function P(t,e,n){const o=c(e),i=S(e),l=\"fixed\"===n,s=R(t,!0,l,e);let u={scrollLeft:0,scrollTop:0};const a=w(0);if(o||!o&&!l)if((\"body\"!==r(e)||f(i))&&(u=E(e)),c(e)){const t=R(e,!0,l,e);a.x=t.x+e.clientLeft,a.y=t.y+e.clientTop}else i&&(a.x=C(i));return{x:s.left+u.scrollLeft-a.x,y:s.top+u.scrollTop-a.y,width:s.width,height:s.height}}const A={getClippingRect:function(t){let{element:e,boundary:n,rootBoundary:i,strategy:c}=t;const s=\"clippingAncestors\"===n?function(t,e){const n=e.get(t);if(n)return n;let i=D(t).filter((t=>l(t)&&\"body\"!==r(t))),c=null;const s=\"fixed\"===o(t).position;let u=s?F(t):t;for(;l(u)&&!h(u);){const e=o(u),n=a(u);n||\"fixed\"!==e.position||(c=null),(s?!n&&!c:!n&&\"static\"===e.position&&c&&[\"absolute\",\"fixed\"].includes(c.position)||f(u)&&!n&&H(t,u))?i=i.filter((t=>t!==u)):c=e,u=F(u)}return e.set(t,i),i}(e,this._c):[].concat(n),u=[...s,i],d=u[0],g=u.reduce(((t,n)=>{const o=W(e,n,c);return t.top=m(o.top,t.top),t.right=p(o.right,t.right),t.bottom=p(o.bottom,t.bottom),t.left=m(o.left,t.left),t}),W(e,d,c));return{width:g.right-g.left,height:g.bottom-g.top,x:g.left,y:g.top}},convertOffsetParentRelativeRectToViewportRelativeRect:function(t){let{rect:e,offsetParent:n,strategy:o}=t;const i=c(n),l=S(n);if(n===l)return e;let s={scrollLeft:0,scrollTop:0},u=w(1);const a=w(0);if((i||!i&&\"fixed\"!==o)&&((\"body\"!==r(n)||f(l))&&(s=E(n)),c(n))){const t=R(n);u=b(n),a.x=t.x+n.clientLeft,a.y=t.y+n.clientTop}return{width:e.width*u.x,height:e.height*u.y,x:e.x*u.x-s.scrollLeft*u.x+a.x,y:e.y*u.y-s.scrollTop*u.y+a.y}},isElement:l,getDimensions:function(t){return x(t)},getOffsetParent:M,getDocumentElement:S,getScale:b,async getElementRects(t){let{reference:e,floating:n,strategy:o}=t;const i=this.getOffsetParent||M,r=this.getDimensions;return{reference:P(e,await i(n),o),floating:{x:0,y:0,...await r(n)}}},getClientRects:t=>Array.from(t.getClientRects()),isRTL:t=>\"rtl\"===o(t).direction};function V(t,e,n,o){void 0===o&&(o={});const{ancestorScroll:i=!0,ancestorResize:r=!0,elementResize:c=\"function\"==typeof ResizeObserver,layoutShift:l=\"function\"==typeof IntersectionObserver,animationFrame:s=!1}=o,f=v(t),u=i||r?[...f?D(f):[],...D(e)]:[];u.forEach((t=>{i&&t.addEventListener(\"scroll\",n,{passive:!0}),r&&t.addEventListener(\"resize\",n)}));const a=f&&l?function(t,e){let n,o=null;const i=S(t);function r(){clearTimeout(n),o&&o.disconnect(),o=null}return function c(l,s){void 0===l&&(l=!1),void 0===s&&(s=1),r();const{left:f,top:u,width:a,height:d}=t.getBoundingClientRect();if(l||e(),!a||!d)return;const h={rootMargin:-y(u)+\"px \"+-y(i.clientWidth-(f+a))+\"px \"+-y(i.clientHeight-(u+d))+\"px \"+-y(f)+\"px\",threshold:m(0,p(1,s))||1};let g=!0;function w(t){const e=t[0].intersectionRatio;if(e!==s){if(!g)return c();e?c(!1,e):n=setTimeout((()=>{c(!1,1e-7)}),100)}g=!1}try{o=new IntersectionObserver(w,{...h,root:i.ownerDocument})}catch(t){o=new IntersectionObserver(w,h)}o.observe(t)}(!0),r}(f,n):null;let d,h=-1,g=null;c&&(g=new ResizeObserver((t=>{let[o]=t;o&&o.target===f&&g&&(g.unobserve(e),cancelAnimationFrame(h),h=requestAnimationFrame((()=>{g&&g.observe(e)}))),n()})),f&&!s&&g.observe(f),g.observe(e));let w=s?R(t):null;return s&&function e(){const o=R(t);!w||o.x===w.x&&o.y===w.y&&o.width===w.width&&o.height===w.height||n();w=o,d=requestAnimationFrame(e)}(),n(),()=>{u.forEach((t=>{i&&t.removeEventListener(\"scroll\",n),r&&t.removeEventListener(\"resize\",n)})),a&&a(),g&&g.disconnect(),g=null,s&&cancelAnimationFrame(d)}}const B=(t,n,o)=>{const i=new Map,r={platform:A,...o},c={...r.platform,_c:i};return e(t,n,{...r,platform:c})};export{V as autoUpdate,B as computePosition,D as getOverflowAncestors,A as platform};\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$1({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      } else if (element) {\n        return arrow$1({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length, i, keys;\n  if (a && b && typeof a == 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/react\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (node != referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, [_setReference]);\n  const setFloating = React.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, [_setFloating]);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        isPositioned: true\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      } else {\n        update();\n      }\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\nexport { arrow, useFloating };\n","var getDefaultParent = function (originalTarget) {\n    if (typeof document === 'undefined') {\n        return null;\n    }\n    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;\n    return sampleTarget.ownerDocument.body;\n};\nvar counterMap = new WeakMap();\nvar uncontrolledNodes = new WeakMap();\nvar markerMap = {};\nvar lockCount = 0;\nvar unwrapHost = function (node) {\n    return node && (node.host || unwrapHost(node.parentNode));\n};\nvar correctTargets = function (parent, targets) {\n    return targets\n        .map(function (target) {\n        if (parent.contains(target)) {\n            return target;\n        }\n        var correctedTarget = unwrapHost(target);\n        if (correctedTarget && parent.contains(correctedTarget)) {\n            return correctedTarget;\n        }\n        console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');\n        return null;\n    })\n        .filter(function (x) { return Boolean(x); });\n};\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @param {String} [controlAttribute] - html Attribute to control\n * @return {Undo} undo command\n */\nvar applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {\n    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n    if (!markerMap[markerName]) {\n        markerMap[markerName] = new WeakMap();\n    }\n    var markerCounter = markerMap[markerName];\n    var hiddenNodes = [];\n    var elementsToKeep = new Set();\n    var elementsToStop = new Set(targets);\n    var keep = function (el) {\n        if (!el || elementsToKeep.has(el)) {\n            return;\n        }\n        elementsToKeep.add(el);\n        keep(el.parentNode);\n    };\n    targets.forEach(keep);\n    var deep = function (parent) {\n        if (!parent || elementsToStop.has(parent)) {\n            return;\n        }\n        Array.prototype.forEach.call(parent.children, function (node) {\n            if (elementsToKeep.has(node)) {\n                deep(node);\n            }\n            else {\n                var attr = node.getAttribute(controlAttribute);\n                var alreadyHidden = attr !== null && attr !== 'false';\n                var counterValue = (counterMap.get(node) || 0) + 1;\n                var markerValue = (markerCounter.get(node) || 0) + 1;\n                counterMap.set(node, counterValue);\n                markerCounter.set(node, markerValue);\n                hiddenNodes.push(node);\n                if (counterValue === 1 && alreadyHidden) {\n                    uncontrolledNodes.set(node, true);\n                }\n                if (markerValue === 1) {\n                    node.setAttribute(markerName, 'true');\n                }\n                if (!alreadyHidden) {\n                    node.setAttribute(controlAttribute, 'true');\n                }\n            }\n        });\n    };\n    deep(parentNode);\n    elementsToKeep.clear();\n    lockCount++;\n    return function () {\n        hiddenNodes.forEach(function (node) {\n            var counterValue = counterMap.get(node) - 1;\n            var markerValue = markerCounter.get(node) - 1;\n            counterMap.set(node, counterValue);\n            markerCounter.set(node, markerValue);\n            if (!counterValue) {\n                if (!uncontrolledNodes.has(node)) {\n                    node.removeAttribute(controlAttribute);\n                }\n                uncontrolledNodes.delete(node);\n            }\n            if (!markerValue) {\n                node.removeAttribute(markerName);\n            }\n        });\n        lockCount--;\n        if (!lockCount) {\n            // clear\n            counterMap = new WeakMap();\n            counterMap = new WeakMap();\n            uncontrolledNodes = new WeakMap();\n            markerMap = {};\n        }\n    };\n};\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Undo} undo command\n */\nexport var hideOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) { markerName = 'data-aria-hidden'; }\n    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\n    if (!activeParentNode) {\n        return function () { return null; };\n    }\n    // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10\n    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));\n    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');\n};\n/**\n * Marks everything except given node(or nodes) as inert\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Undo} undo command\n */\nexport var inertOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) { markerName = 'data-inert-ed'; }\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\n    if (!activeParentNode) {\n        return function () { return null; };\n    }\n    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');\n};\n/**\n * @returns if current browser supports inert\n */\nexport var supportsInert = function () {\n    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');\n};\n/**\n * Automatic function to \"suppress\" DOM elements - _hide_ or _inert_ in the best possible way\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Undo} undo command\n */\nexport var suppressOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) { markerName = 'data-suppressed'; }\n    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);\n};\n","/*!\n* tabbable 6.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\n// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function (element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nvar isInert = function isInert(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n  var inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  var result = inert || lookUp && node && isInert(node.parentNode); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nvar isContentEditable = function isContentEditable(node) {\n  var _node$getAttribute2;\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nvar hasTabIndex = function hasTabIndex(node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nvar getTabIndex = function getTabIndex(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRoot;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  var nodeRoot = node && getRootNode(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled ||\n  // we must do an inert look up to filter out any elements inside an inert ancestor\n  //  because we're limited in the type of selectors we can use in JSDom (see related\n  //  note related to `candidateSelectors`)\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, getTabIndex, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","import { platform, getOverflowAncestors, useFloating as useFloating$1, offset, detectOverflow } from '@floating-ui/react-dom';\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/react-dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { hideOthers } from 'aria-hidden';\nimport { tabbable } from 'tabbable';\nimport { createPortal, flushSync } from 'react-dom';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  React.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n}\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = React[/*#__PURE__*/'useId'.toString()];\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */\nconst useId = useReactId || useFloatingId;\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(_ref, ref) {\n  let {\n    context: {\n      placement,\n      elements: {\n        floating\n      },\n      middlewareData: {\n        arrow\n      }\n    },\n    width = 14,\n    height = 7,\n    tipRadius = 0,\n    strokeWidth = 0,\n    staticOffset,\n    stroke,\n    d,\n    style: {\n      transform,\n      ...restStyle\n    } = {},\n    ...rest\n  } = _ref;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!ref) {\n      console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');\n    }\n  }\n  const clipPathId = useId();\n  if (!floating) {\n    return null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  strokeWidth *= 2;\n  const halfStrokeWidth = strokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const [side, alignment] = placement.split('-');\n  const isRTL = platform.isRTL(floating);\n  const isCustomShape = !!d;\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n  if (staticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';\n  const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({}, rest, {\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + strokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: {\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n      transform: \"\" + rotation + (transform != null ? transform : ''),\n      ...restStyle\n    }\n  }), strokeWidth > 0 && /*#__PURE__*/React.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n    strokeWidth: strokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    stroke: strokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/React.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + strokeWidth,\n    height: width\n  })));\n});\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the floating tree, returning its id.\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null ? void 0 : tree.addNode(node);\n    return () => {\n      tree == null ? void 0 : tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(_ref) {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n}\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(_ref2) {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [nodesRef, addNode, removeNode, events])\n  }, children);\n}\n\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\n\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\nfunction getWindow(value) {\n  return getDocument(value).defaultView || window;\n}\nfunction isElement(value) {\n  return value ? value instanceof getWindow(value).Element : false;\n}\nfunction isHTMLElement(value) {\n  return value ? value instanceof getWindow(value).HTMLElement : false;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  const androidRe = /Android/i;\n  if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== 'mouse' ||\n  // iOS VoiceOver returns 0.333 for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\n\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode && child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\n\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nconst safePolygonIdentifier = 'data-floating-ui-safe-polygon';\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !isMouseLikePointerType(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef();\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef();\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  const unbindMouseMoveRef = React.useRef(() => {});\n  const isHoverOpen = React.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When dismissing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss() {\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      blockMouseMoveRef.current = true;\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [enabled, events]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event);\n      }\n    }\n    const html = getDocument(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);\n  const closeWithDelay = React.useCallback(function (event, runElseBranch) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false, event), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false, event);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = React.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = React.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = getDocument(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true, event);\n        }, openDelay);\n      } else {\n        onOpenChange(true, event);\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = getDocument(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            // Should the event expose that it was closed by `safePolygon`?\n            closeWithDelay(event);\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !contains(floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null ? void 0 : handleCloseRef.current({\n        ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay(event);\n        }\n      })(event);\n    }\n    if (isElement(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = getDocument(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if (isElement(domReference) && floating) {\n        var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n        const ref = domReference;\n        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  React.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove(event) {\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true, event.nativeEvent);\n            }\n          }, restMs);\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave(event) {\n          events.emit('dismiss', {\n            type: 'mouseLeave',\n            data: {\n              returnFocus: false\n            }\n          });\n          closeWithDelay(event.nativeEvent, false);\n        }\n      }\n    };\n  }, [events, enabled, restMs, open, onOpenChange, closeWithDelay]);\n}\n\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {},\n  isInstantPhase: false\n});\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay,\n    timeoutMs = 0\n  } = _ref;\n  const [state, setState] = React.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = React.useRef(null);\n  const setCurrentId = React.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setState, setCurrentId])\n  }, children);\n};\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = useDelayGroupContext();\n  index(() => {\n    if (currentId) {\n      setState({\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      });\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  index(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      } else {\n        unset();\n      }\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  index(() => {\n    if (open) {\n      setCurrentId(id);\n    }\n  }, [open, setCurrentId, id]);\n};\n\n/**\n * Find the real active element. Traverses into shadowRoots.\n */\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {\n    var _activeElement, _activeElement$shadow;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\n\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\n\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = tabbable(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = React.useState();\n  index(() => {\n    if (isSafari()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, {\n    ref: ref,\n    tabIndex: 0\n    // Role is only for VoiceOver\n    ,\n    role: role,\n    \"aria-hidden\": role ? undefined : true,\n    \"data-floating-ui-focus-guard\": \"\",\n    style: HIDDEN_STYLES\n  }));\n});\n\nconst PortalContext = /*#__PURE__*/React.createContext(null);\nfunction useFloatingPortalNode(_temp) {\n  let {\n    id,\n    root\n  } = _temp === void 0 ? {} : _temp;\n  const [portalNode, setPortalNode] = React.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const data = React.useMemo(() => ({\n    id,\n    root,\n    portalContext,\n    uniqueId\n  }), [id, root, portalContext, uniqueId]);\n  const dataRef = React.useRef();\n  index(() => {\n    return () => {\n      portalNode == null ? void 0 : portalNode.remove();\n    };\n  }, [portalNode, data]);\n  index(() => {\n    if (dataRef.current === data) return;\n    dataRef.current = data;\n    const {\n      id,\n      root,\n      portalContext,\n      uniqueId\n    } = data;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    const attr = 'data-floating-ui-portal';\n    if (existingIdRoot) {\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      existingIdRoot.appendChild(subRoot);\n      setPortalNode(subRoot);\n    } else {\n      let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n      if (container && !isElement(container)) container = container.current;\n      container = container || document.body;\n      let idWrapper = null;\n      if (id) {\n        idWrapper = document.createElement('div');\n        idWrapper.id = id;\n        container.appendChild(idWrapper);\n      }\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      container = idWrapper || container;\n      container.appendChild(subRoot);\n      setPortalNode(subRoot);\n    }\n  }, [data]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element  by default,\n * outside of the app root and into the body.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(_ref) {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = React.useState(null);\n  const beforeOutsideRef = React.useRef(null);\n  const afterOutsideRef = React.useRef(null);\n  const beforeInsideRef = React.useRef(null);\n  const afterInsideRef = React.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  React.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/React.createElement(PortalContext.Provider, {\n    value: React.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null ? void 0 : prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null ? void 0 : nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n      }\n    }\n  }));\n}\nconst usePortalContext = () => React.useContext(PortalContext);\n\nconst VisuallyHiddenDismiss = /*#__PURE__*/React.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/React.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    order = ['content'],\n    guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = props;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n\n  // Controlled by `useListNavigation`.\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const previouslyFocusedElementRef = React.useRef(null);\n  const isPointerDownRef = React.useRef(false);\n  const isInsidePortal = portalContext != null;\n\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isTypeableCombobox = domReference && domReference.getAttribute('role') === 'combobox' && isTypeableElement(domReference);\n  const getTabbableContent = React.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = React.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  React.useEffect(() => {\n    if (!modal) {\n      return;\n    }\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (contains(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isTypeableCombobox) {\n          stopEvent(event);\n        }\n        const els = getTabbableElements();\n        const target = getTarget(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          stopEvent(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          stopEvent(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = getDocument(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [domReference, floating, modal, orderRef, refs, isTypeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    if (!closeOnFocusOut) {\n      return;\n    }\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute('data-floating-ui-focus-guard') || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== previouslyFocusedElementRef.current) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event);\n        }\n      });\n    }\n    if (floating && isHTMLElement(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  React.useEffect(() => {\n    var _portalContext$portal;\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll('[data-floating-ui-portal]')) || []);\n    function getDismissButtons() {\n      return [startDismissButtonRef.current, endDismissButtonRef.current].filter(Boolean);\n    }\n    if (floating && modal) {\n      const insideNodes = [floating, ...portalNodes, ...getDismissButtons()];\n      const cleanup = hideOthers(orderRef.current.includes('reference') || isTypeableCombobox ? insideNodes.concat(domReference || []) : insideNodes);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [domReference, floating, modal, orderRef, portalContext, isTypeableCombobox]);\n  React.useEffect(() => {\n    if (modal && !guards && floating) {\n      const tabIndexValues = [];\n      const options = getTabbableOptions();\n      const allTabbable = tabbable(getDocument(floating).body, options);\n      const floatingTabbable = getTabbableElements();\n\n      // Exclude all tabbable elements that are part of the order\n      const elements = allTabbable.filter(el => !floatingTabbable.includes(el));\n      elements.forEach((el, i) => {\n        tabIndexValues[i] = el.getAttribute('tabindex');\n        el.setAttribute('tabindex', '-1');\n      });\n      return () => {\n        elements.forEach((el, i) => {\n          const value = tabIndexValues[i];\n          if (value == null) {\n            el.removeAttribute('tabindex');\n          } else {\n            el.setAttribute('tabindex', value);\n          }\n        });\n      };\n    }\n  }, [floating, modal, guards, getTabbableElements]);\n  index(() => {\n    if (!floating) return;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floating);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n      const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floating\n        });\n      }\n    });\n  }, [open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  index(() => {\n    if (!floating) return;\n    let preventReturnFocusScroll = false;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n    const contextData = dataRef.current;\n    previouslyFocusedElementRef.current = previouslyFocusedElement;\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onDismiss(payload) {\n      if (payload.type === 'escapeKey' && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (['referencePress', 'escapeKey'].includes(payload.type)) {\n        return;\n      }\n      const returnFocus = payload.data.returnFocus;\n      if (typeof returnFocus === 'object') {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = returnFocus.preventScroll;\n      } else {\n        preventReturnFocusRef.current = !returnFocus;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n      const activeEl = activeElement(doc);\n      const shouldFocusReference = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      }) || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      returnFocusRef.current && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {\n        enqueueFocus(previouslyFocusedElementRef.current, {\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored  leaving the root\n          // reference focused as desired.\n          cancelPrevious: false,\n          preventScroll: preventReturnFocusScroll\n        });\n      }\n    };\n  }, [floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (!portalContext) return;\n    portalContext.setFocusManagerState({\n      ...context,\n      modal,\n      closeOnFocusOut,\n      open\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [portalContext, modal, open, closeOnFocusOut, context]);\n  index(() => {\n    if (floating && typeof MutationObserver === 'function') {\n      const handleMutation = () => {\n        const tabIndex = floating.getAttribute('tabindex');\n        if (orderRef.current.includes('floating') || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n          if (tabIndex !== '0') {\n            floating.setAttribute('tabindex', '0');\n          }\n        } else if (tabIndex !== '-1') {\n          floating.setAttribute('tabindex', '-1');\n        }\n      };\n      handleMutation();\n      const observer = new MutationObserver(handleMutation);\n      observer.observe(floating, {\n        childList: true,\n        subtree: true,\n        attributes: true\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [floating, refs, orderRef, getTabbableContent]);\n  function renderDismissButton(location) {\n    return visuallyHiddenDismiss && modal ? /*#__PURE__*/React.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss') : null;\n  }\n  const shouldRenderGuards = guards && !isTypeableCombobox && (isInsidePortal || modal);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null ? void 0 : nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();\n        }\n      }\n    }\n  }), !isTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null ? void 0 : prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nfunction areMapsEqual(map1, map2) {\n  if (map1.size !== map2.size) {\n    return false;\n  }\n  for (const [key, value] of map1.entries()) {\n    if (value !== map2.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst FloatingListContext = /*#__PURE__*/React.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(_ref) {\n  let {\n    children,\n    elementsRef,\n    labelsRef\n  } = _ref;\n  const [map, setMap] = React.useState(() => new Map());\n  const register = React.useCallback(node => {\n    setMap(prevMap => new Map(prevMap).set(node, null));\n  }, []);\n  const unregister = React.useCallback(node => {\n    setMap(prevMap => {\n      const map = new Map(prevMap);\n      map.delete(node);\n      return map;\n    });\n  }, []);\n  index(() => {\n    const newMap = new Map(map);\n    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n    nodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    if (!areMapsEqual(map, newMap)) {\n      setMap(newMap);\n    }\n  }, [map]);\n  return /*#__PURE__*/React.createElement(FloatingListContext.Provider, {\n    value: React.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef])\n  }, children);\n}\nfunction useListItem(_temp) {\n  let {\n    label\n  } = _temp === void 0 ? {} : _temp;\n  const [index$1, setIndex] = React.useState(null);\n  const componentRef = React.useRef(null);\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = React.useContext(FloatingListContext);\n  const ref = React.useCallback(node => {\n    componentRef.current = node;\n    if (index$1 !== null) {\n      elementsRef.current[index$1] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index$1, elementsRef, labelsRef, label]);\n  index(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  index(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return React.useMemo(() => ({\n    ref,\n    index: index$1 == null ? -1 : index$1\n  }), [index$1, ref]);\n}\n\nconst identifier = 'data-floating-ui-scroll-lock';\n\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n    lockScroll = false,\n    ...rest\n  } = _ref;\n  index(() => {\n    var _window$visualViewpor, _window$visualViewpor2;\n    if (!lockScroll) {\n      return;\n    }\n    const alreadyLocked = document.body.hasAttribute(identifier);\n    if (alreadyLocked) {\n      return;\n    }\n    document.body.setAttribute(identifier, '');\n\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n      Object.assign(document.body.style, {\n        overflow: 'hidden',\n        [paddingProp]: scrollbarWidth + \"px\"\n      });\n      return () => {\n        document.body.removeAttribute(identifier);\n        Object.assign(document.body.style, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n      };\n    }\n\n    // iOS 12 does not support `visualViewport`.\n    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n    const scrollX = window.pageXOffset;\n    const scrollY = window.pageYOffset;\n    Object.assign(document.body.style, {\n      position: 'fixed',\n      overflow: 'hidden',\n      top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n      left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n      right: '0',\n      [paddingProp]: scrollbarWidth + \"px\"\n    });\n    return () => {\n      Object.assign(document.body.style, {\n        position: '',\n        overflow: '',\n        top: '',\n        left: '',\n        right: '',\n        [paddingProp]: ''\n      });\n      document.body.removeAttribute(identifier);\n      window.scrollTo(scrollX, scrollY);\n    };\n  }, [lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nfunction isButtonTarget(event) {\n  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return isTypeableElement(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = props;\n  const pointerTypeRef = React.useRef();\n  const didKeyDownRef = React.useRef(false);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n              onOpenChange(false, event.nativeEvent);\n            }\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true, event.nativeEvent);\n          }\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n              onOpenChange(false, event.nativeEvent);\n            }\n          } else {\n            onOpenChange(true, event.nativeEvent);\n          }\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n            didKeyDownRef.current = true;\n          }\n          if (event.key === 'Enter') {\n            if (open) {\n              if (toggle) {\n                onOpenChange(false, event.nativeEvent);\n              }\n            } else {\n              onOpenChange(true, event.nativeEvent);\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ' && didKeyDownRef.current) {\n            didKeyDownRef.current = false;\n            if (open) {\n              if (toggle) {\n                onOpenChange(false, event.nativeEvent);\n              }\n            } else {\n              onOpenChange(true, event.nativeEvent);\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n}\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = React.useRef(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nfunction createVirtualElement(domRef, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domRef.current || undefined,\n    getBoundingClientRect() {\n      var _domRef$current, _data$dataRef$current;\n      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    refs,\n    dataRef,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = React.useRef(false);\n  const cleanupListenerRef = React.useRef(null);\n  const [pointerType, setPointerType] = React.useState();\n  const [reactive, setReactive] = React.useState([]);\n  const setReference = useEffectEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(refs.domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEffectEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = isMouseLikePointerType(pointerType) ? floating : open;\n  const addListener = React.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = getWindow(refs.floating.current);\n    function handleMouseMove(event) {\n      const target = getTarget(event);\n      if (!contains(refs.floating.current, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(refs.domReference.current);\n  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n  React.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  React.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  React.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      }\n    };\n  }, [enabled, handleReferenceEnterOrMove]);\n}\n\n/**\n * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n *\n * @param event The event whose target/composedPath to check\n * @param node The node to check against\n * @returns Whether the event.target/composedPath is within the node.\n */\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeBubblesProp = bubbles => {\n  var _bubbles$escapeKey, _bubbles$outsidePress;\n  return {\n    escapeKeyBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$escapeKey = bubbles == null ? void 0 : bubbles.escapeKey) != null ? _bubbles$escapeKey : false,\n    outsidePressBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$outsidePress = bubbles == null ? void 0 : bubbles.outsidePress) != null ? _bubbles$outsidePress : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested  by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles\n  } = props;\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = React.useRef(false);\n  const {\n    escapeKeyBubbles,\n    outsidePressBubbles\n  } = normalizeBubblesProp(bubbles);\n  const closeOnEscapeKeyDown = useEffectEvent(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    events.emit('dismiss', {\n      type: 'escapeKey',\n      data: {\n        returnFocus: {\n          preventScroll: false\n        }\n      }\n    });\n    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event);\n  });\n  const closeOnPressOutside = useEffectEvent(event => {\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = getTarget(event);\n\n    // Check if the click occurred on the scrollbar\n    if (isHTMLElement(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = getWindow(floating).getComputedStyle(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    events.emit('dismiss', {\n      type: 'outsidePress',\n      data: {\n        returnFocus: nested ? {\n          preventScroll: true\n        } : isVirtualClick(event) || isVirtualPointerEvent(event)\n      }\n    });\n    onOpenChange(false, event);\n  });\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onScroll(event) {\n      onOpenChange(false, event);\n    }\n    const doc = getDocument(floating);\n    escapeKey && doc.addEventListener('keydown', closeOnEscapeKeyDown);\n    outsidePress && doc.addEventListener(outsidePressEvent, closeOnPressOutside);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(domReference)) {\n        ancestors = getOverflowAncestors(domReference);\n      }\n      if (isElement(floating)) {\n        ancestors = ancestors.concat(getOverflowAncestors(floating));\n      }\n      if (!isElement(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat(getOverflowAncestors(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', closeOnEscapeKeyDown);\n      outsidePress && doc.removeEventListener(outsidePressEvent, closeOnPressOutside);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, closeOnPressOutside]);\n  React.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [bubbleHandlerKeys[referencePressEvent]]: event => {\n          if (referencePress) {\n            events.emit('dismiss', {\n              type: 'referencePress',\n              data: {\n                returnFocus: false\n              }\n            });\n            onOpenChange(false, event.nativeEvent);\n          }\n        }\n      },\n      floating: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/react\n */\nfunction useFloating(options) {\n  var _options$elements;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  const [_domReference, setDomReference] = React.useState(null);\n  const domReference = ((_options$elements = options.elements) == null ? void 0 : _options$elements.reference) || _domReference;\n  const position = useFloating$1(options);\n  const tree = useFloatingTree();\n  const onOpenChange = useEffectEvent((open, event) => {\n    if (open) {\n      dataRef.current.openEvent = event;\n    }\n    unstable_onOpenChange == null ? void 0 : unstable_onOpenChange(open, event);\n  });\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const floatingId = useId();\n  const setPositionReference = React.useCallback(node => {\n    const positionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    position.refs.setReference(positionReference);\n  }, [position.refs]);\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = React.useMemo(() => ({\n    ...position,\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    floatingId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    refs,\n    elements: {\n      floating,\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    keyboardOnly = true\n  } = props;\n  const pointerTypeRef = React.useRef('');\n  const blockFocusRef = React.useRef(false);\n  const timeoutRef = React.useRef();\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const doc = getDocument(floating);\n    const win = doc.defaultView || window;\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    win.addEventListener('blur', onBlur);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n    };\n  }, [floating, domReference, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss(payload) {\n      if (payload.type === 'referencePress' || payload.type === 'escapeKey') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [events, enabled]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(_ref) {\n          let {\n            pointerType\n          } = _ref;\n          pointerTypeRef.current = pointerType;\n          blockFocusRef.current = !!(pointerType && keyboardOnly);\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          var _dataRef$current$open;\n          if (blockFocusRef.current) {\n            return;\n          }\n\n          // Dismiss with click should ignore the subsequent `focus` trigger,\n          // but only if the click originated inside the reference element.\n          if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && isEventTargetWithin(dataRef.current.openEvent, domReference)) {\n            return;\n          }\n          onOpenChange(true, event.nativeEvent);\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute('data-floating-ui-focus-guard') && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = setTimeout(() => {\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false, event.nativeEvent);\n          });\n        }\n      }\n    };\n  }, [enabled, keyboardOnly, domReference, refs, dataRef, onOpenChange]);\n}\n\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...userProps,\n    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/react#interaction-hooks\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  propsList.map(key => key == null ? void 0 : key.item));\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\n\nlet isPreventScrollSupported = false;\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  let index = startingIndex;\n  do {\n    var _list$index, _list$index2;\n    index = index + (decrement ? -amount : amount);\n  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));\n  return index;\n}\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true\n  } = props;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEffectEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const isPointerModalityRef = React.useRef(true);\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousMountedRef = React.useRef(!!floating);\n  const forceSyncFocus = React.useRef(false);\n  const forceScrollIntoViewRef = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = React.useState();\n  const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (!item) return;\n    if (virtual) {\n      setActiveId(item.id);\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null ? void 0 : item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (previousMountedRef.current && !floating && tree) {\n      var _nodes$find, _nodes$find$context;\n      const nodes = tree.nodesRef.current;\n      const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null ? void 0 : (_nodes$find$context = _nodes$find.context) == null ? void 0 : _nodes$find$context.elements.floating;\n      const activeEl = activeElement(getDocument(floating));\n      const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n      if (parent && !treeContainsActiveEl) {\n        parent.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [enabled, floating, tree, parentId]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = React.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = {\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref3) {\n          let {\n            currentTarget\n          } = _ref3;\n          syncCurrentTarget(currentTarget);\n        },\n        onPointerLeave(_ref4) {\n          let {\n            pointerType\n          } = _ref4;\n          if (!isPointerModalityRef.current || pointerType === 'touch') {\n            return;\n          }\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n          onNavigate(null);\n          if (!virtual) {\n            enqueueFocus(refs.floating.current, {\n              preventScroll: true\n            });\n          }\n        }\n      })\n    };\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false, event.nativeEvent);\n        if (isHTMLElement(domReference)) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        stopEvent(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        stopEvent(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const prevIndex = indexRef.current;\n        if (event.key === ARROW_UP) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = maxIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              decrement: true,\n              disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {\n              const col = prevIndex % cols;\n              const maxCol = maxIndex % cols;\n              const offset = maxIndex - (maxCol - col);\n              if (maxCol === col) {\n                indexRef.current = maxIndex;\n              } else {\n                indexRef.current = maxCol > col ? offset : offset - cols;\n              }\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        }\n        if (event.key === ARROW_DOWN) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = minIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex % cols - cols,\n                amount: cols,\n                disabledIndices\n              });\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        }\n\n        // Remains on the same row/column.\n        if (orientation === 'both') {\n          const prevRow = Math.floor(prevIndex / cols);\n          if (event.key === ARROW_RIGHT) {\n            stopEvent(event);\n            if (prevIndex % cols !== cols - 1) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex - prevIndex % cols - 1,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          if (event.key === ARROW_LEFT) {\n            stopEvent(event);\n            if (prevIndex % cols !== 0) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices,\n                decrement: true\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex + (cols - prevIndex % cols),\n                  decrement: true,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex + (cols - prevIndex % cols),\n                decrement: true,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          const lastRow = Math.floor(maxIndex / cols) === prevRow;\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            if (loop && lastRow) {\n              indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            } else {\n              indexRef.current = prevIndex;\n            }\n          }\n          onNavigate(indexRef.current);\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': activeId\n    };\n    return {\n      reference: {\n        ...ariaActiveDescendantProp,\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          if (virtual && open) {\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          const isNavigationKey = isArrowKey || event.key === 'Enter' || event.key.trim() === '';\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isCrossKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossKey) {\n              stopEvent(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true, event.nativeEvent);\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            stopEvent(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true, event.nativeEvent);\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...ariaActiveDescendantProp,\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      },\n      item\n    };\n  }, [domReference, refs, activeId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item]);\n}\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/useMergeRefs\n */\nfunction useMergeRefs(refs) {\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const referenceId = useId();\n  return React.useMemo(() => {\n    const floatingProps = {\n      id: floatingId,\n      role\n    };\n    if (!enabled) {\n      return {};\n    }\n    if (role === 'tooltip') {\n      return {\n        reference: {\n          'aria-describedby': open ? floatingId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,\n        'aria-controls': open ? floatingId : undefined,\n        ...(role === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(role === 'menu' && {\n          id: referenceId\n        })\n      },\n      floating: {\n        ...floatingProps,\n        ...(role === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      }\n    };\n  }, [enabled, role, open, floatingId, referenceId]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = React.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  React.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = React.useState(false);\n  const [status, setStatus] = React.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    } else {\n      setInitiated(true);\n      setStatus('close');\n    }\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = React.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = React.useState(() => ({\n    ...execWithArgsOrReturn(unstable_common, fnArgs),\n    ...execWithArgsOrReturn(unstable_initial, fnArgs)\n  }));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = React.useRef(null);\n  const onMatch = useEffectEvent(unstable_onMatch);\n  const onTypingChange = useEffectEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setTypingChange(value) {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    }\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    function onKeyDown(event) {\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        stopEvent(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else if (event.key !== ' ') {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown,\n        onKeyUp(event) {\n          if (event.key === ' ') {\n            setTypingChange(false);\n          }\n        }\n      }\n    };\n  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n}\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = props;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await offset(-item.offsetTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        flushSync(() => onFallbackChange(true));\n      } else {\n        flushSync(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = React.useRef(false);\n  const prevScrollTopRef = React.useRef(null);\n  const initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              flushSync(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safePolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  let timeoutId;\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = performance.now();\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      } else if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutId = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\nexport { FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingList, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListItem, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };\n","import React, { useState } from 'react';\nimport { createPortal } from 'react-dom';\n\nimport useIsomorphicLayoutEffect from '../../hooks/useIsomorphicLayoutEffect';\n\nexport interface Props {\n  children: React.ReactNode;\n  container?: HTMLElement;\n  disabled?: boolean;\n}\n\nconst Portal = React.forwardRef(({ children, container, disabled }: Props, ref) => {\n  const [mountNode, setMountNode] = useState<Element | null>(null);\n\n  useIsomorphicLayoutEffect(() => {\n    if (disabled) {\n      setMountNode(null);\n      return;\n    }\n    if (!container) {\n      let dom = document.getElementById('visits-style-portals');\n      if (!dom) {\n        dom = document.createElement('div');\n        dom.id = 'visits-style-portals';\n        document.body.appendChild(dom);\n      }\n      setMountNode(dom);\n      return;\n    }\n    setMountNode(container);\n  }, [container, disabled]);\n\n  return mountNode ? createPortal(children, mountNode) : null;\n});\nPortal.displayName = 'Portal';\n\nexport default Portal;\n"],"names":["t","e","n","o","i","r","a","l","s","c","f","m","u","g","d","p","h","y","x","w","v","b","R","A","P","E","T","D","L","k","O","B","C","H","S","F","W","z","M","V","index","useLayoutEffect","useEffect","deepEqual","length","keys","key","getDPR","element","roundByDPR","value","dpr","useLatestRef","ref","React.useRef","useFloating","options","placement","strategy","middleware","platform","externalReference","externalFloating","transform","whileElementsMounted","open","data","setData","React.useState","latestMiddleware","setLatestMiddleware","_reference","_setReference","_floating","_setFloating","setReference","React.useCallback","node","referenceRef","setFloating","floatingRef","referenceEl","floatingEl","dataRef","whileElementsMountedRef","platformRef","update","config","computePosition","fullData","isMountedRef","ReactDOM.flushSync","refs","React.useMemo","elements","floatingStyles","initialStyles","getDefaultParent","originalTarget","sampleTarget","counterMap","uncontrolledNodes","markerMap","lockCount","unwrapHost","correctTargets","parent","targets","target","correctedTarget","applyAttributeToOthers","parentNode","markerName","controlAttribute","markerCounter","hiddenNodes","elementsToKeep","elementsToStop","keep","el","deep","attr","alreadyHidden","counterValue","markerValue","hideOthers","activeParentNode","candidateSelectors","candidateSelector","NoElement","matches","getRootNode","_element$getRootNode","isInert","lookUp","_node$getAttribute","inertAtt","inert","result","isContentEditable","_node$getAttribute2","attValue","getCandidates","includeContainer","filter","candidates","getCandidatesIteratively","elementsToCheck","assigned","content","nestedCandidates","validCandidate","shadowRoot","validShadowRoot","_nestedCandidates","hasTabIndex","getTabIndex","getSortOrderTabIndex","isScope","tabIndex","sortOrderedTabbables","isInput","isHiddenInput","isDetailsWithSummary","child","getCheckedRadio","nodes","form","isTabbableRadio","radioScope","queryRadios","name","radioSet","err","checked","isRadio","isNonTabbableRadio","isNodeAttached","_nodeRoot","nodeRoot","nodeRootHost","attached","_nodeRootHost","_nodeRootHost$ownerDo","_node$ownerDocument","_nodeRoot2","_nodeRootHost2","_nodeRootHost2$ownerD","isZeroArea","_node$getBoundingClie","width","height","isHidden","_ref","displayCheck","getShadowRoot","isDirectSummary","nodeUnderDetails","originalNode","parentElement","rootNode","isDisabledFromFieldset","isNodeMatchingSelectorFocusable","isNodeMatchingSelectorTabbable","isValidShadowRootTabbable","shadowHostNode","sortByOrder","regularTabbables","orderedTabbables","item","candidateTabindex","acc","sortable","tabbable","container","_extends","source","serverHandoffComplete","count","genId","useFloatingId","id","setId","React.useEffect","useReactId","React","useId","createPubSub","map","event","_map$get","handler","listener","_map$get2","FloatingNodeContext","React.createContext","FloatingTreeContext","useFloatingParentNodeId","_React$useContext","React.useContext","useFloatingTree","getDocument","getPlatform","uaData","getUserAgent","brand","version","getWindow","isElement","isHTMLElement","isShadowRoot","OwnElement","isVirtualClick","androidRe","isVirtualPointerEvent","isSafari","isMouseLikePointerType","pointerType","strict","values","isReactEvent","contains","next","useRef","safePolygonIdentifier","getDelay","prop","useHover","context","props","onOpenChange","events","domReference","floating","enabled","delay","handleClose","mouseOnly","restMs","move","tree","parentId","handleCloseRef","delayRef","pointerTypeRef","timeoutRef","handlerRef","restTimeoutRef","blockMouseMoveRef","performedPointerEventsMutationRef","unbindMouseMoveRef","isHoverOpen","_dataRef$current$open","type","onDismiss","onLeave","html","closeWithDelay","runElseBranch","closeDelay","cleanupMouseMoveHandler","clearPointerEvents","body","isClickLikeOpenEvent","onMouseEnter","openDelay","onMouseLeave","doc","onScrollMouseLeave","_handleCloseRef$curre","_tree$nodesRef$curren","_tree$nodesRef$curren2","parentFloating","setPointerRef","activeElement","_activeElement","_activeElement$shadow","rafId","enqueueFocus","preventScroll","cancelPrevious","sync","exec","getAncestors","_nodes$find","allAncestors","currentParentId","currentNode","getChildren","allChildren","_node$context","currentChildren","_currentChildren","_node$context2","getTarget","TYPEABLE_SELECTOR","isTypeableElement","stopEvent","getTabbableOptions","getTabbableIn","direction","allTabbable","activeIndex","getNextTabbable","getPreviousTabbable","isOutsideEvent","containerElement","relatedTarget","HIDDEN_STYLES","timeoutId","setActiveElementOnTab","FocusGuard","React.forwardRef","role","setRole","React.createElement","PortalContext","usePortalContext","VisuallyHiddenDismiss","FloatingFocusManager","children","order","guards","initialFocus","returnFocus","modal","visuallyHiddenDismiss","closeOnFocusOut","nodeId","orderRef","initialFocusRef","returnFocusRef","portalContext","ignoreInitialFocus","startDismissButtonRef","endDismissButtonRef","preventReturnFocusRef","previouslyFocusedElementRef","isPointerDownRef","isInsidePortal","isTypeableCombobox","getTabbableContent","getTabbableElements","onKeyDown","els","handlePointerDown","handleFocusOutside","movedToUnrelatedNode","_node$context3","_node$context4","_portalContext$portal","portalNodes","getDismissButtons","insideNodes","cleanup","tabIndexValues","floatingTabbable","previouslyFocusedElement","focusableElements","initialFocusValue","elToFocus","focusAlreadyInsideFloatingEl","preventReturnFocusScroll","contextData","payload","activeEl","_node$context5","handleMutation","observer","renderDismissButton","location","shouldRenderGuards","React.Fragment","nextTabbable","_portalContext$before","prevTabbable","_portalContext$afterO","identifier","FloatingOverlay","lockScroll","rest","_window$visualViewpor","_window$visualViewpor2","paddingProp","scrollbarWidth","offsetLeft","offsetTop","scrollX","scrollY","isButtonTarget","isSpaceIgnored","useClick","eventOption","toggle","ignoreMouse","keyboardHandlers","didKeyDownRef","useInsertionEffect","useSafeInsertionEffect","fn","useEffectEvent","callback","_len","args","_key","createVirtualElement","domRef","offsetX","offsetY","isAutoUpdateEvent","_domRef$current","_data$dataRef$current","domRect","isXAxis","isYAxis","canTrackCursorOnAutoUpdate","isMouseBasedEvent","useClientPoint","axis","initialRef","cleanupListenerRef","setPointerType","reactive","setReactive","handleReferenceEnterOrMove","openCheck","addListener","win","handleMouseMove","setPointerTypeRef","isEventTargetWithin","bubbleHandlerKeys","captureHandlerKeys","normalizeBubblesProp","bubbles","_bubbles$escapeKey","_bubbles$outsidePress","useDismiss","reference","escapeKey","unstable_outsidePress","outsidePressEvent","referencePress","referencePressEvent","ancestorScroll","nested","outsidePressFn","outsidePress","insideReactTreeRef","escapeKeyBubbles","outsidePressBubbles","closeOnEscapeKeyDown","shouldDismiss","_child$context","closeOnPressOutside","insideReactTree","canScrollX","canScrollY","xCond","targetIsInsideChildren","_child$context2","onScroll","ancestors","getOverflowAncestors","ancestor","_doc$defaultView","_options$elements","unstable_onOpenChange","_domReference","setDomReference","position","useFloating$1","domReferenceRef","floatingId","setPositionReference","positionReference","mergeProps","userProps","propsList","elementKey","val","useInteractions","deps","getReferenceProps","getFloatingProps","getItemProps","camelCaseToKebabCase","str","$","ofs","execWithArgsOrReturn","valueOrFn","useDelayUnmount","durationMs","isMounted","setIsMounted","timeout","useTransitionStatus","duration","closeDuration","initiated","setInitiated","status","setStatus","frame","useTransitionStyles","unstable_initial","unstable_open","unstable_close","unstable_common","side","fnArgs","isNumberDuration","openDuration","styles","setStyles","openRef","closeRef","commonRef","closeStyles","commonStyles","openStyles","Portal","mountNode","setMountNode","useState","useIsomorphicLayoutEffect","disabled","dom","document","createPortal","Portal$1"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}